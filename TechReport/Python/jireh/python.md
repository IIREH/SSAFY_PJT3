# 파이썬 학습 전략

우선 점프 투 파이썬을 기본 교재로 삼아 파이썬을 개략적으로 살핀다. 특히 자료형, 조건문, 반복문, 함수, 클래스에 유의하여 살피며 이후 더 심도있는 학습이 필요한 경우 SSAFY의 파이썬 강의 다시보기를 활용한다.

# 자료형

## 숫자
- 정수: 0o/0O, 0x/0X로 진법 표시
- 실수: 일반적인 실수 표기와 과학적 표기법으로 표시
- 숫자형을 위한 연산자(**: power, //: 나눗셈 몫, ...)

## 문자열
- 쌍따옴표나 따옴표를 사용할 수 있으며 내부에 (쌍)따옴표를 기호로 인식
- 연속된 3개의 (쌍)따옴표로 여러 줄의 문자열 저장
- 역슬래시를 이용해 escape char 저장
- +, * 연산 가능
- 배열 첨자 연산 가능, 음수로 뒷 문자 접근 가능, [x:y]로 범위 접근 가능 
- 문자열을 구성할 때 형식문자 사용 가능 (c언어처럼)
- 또는 보간도 사용 가능 (~.format, f.~)
- 그 외 문자열이 제공하는 편리한 메서드들

## 리스트
- 리스트가 가지는 자료들은 자료형이 달라도 상관 없다
- 문자열에서 첨자로 접근하는 것처럼 접근 가능
- 문자열과 달리 mutable
- 그 외 리스트가 제공하는 편리한 메서드들

## 튜플
- 리스트와 비슷하되 immutable!

## 딕셔너리
- 키와 밸류 쌍들의 집합
- 키는 불변하는 값이어야하기에 튜플은 가능하지만 리스트는 불가
- 첨자 연산으로 접근 가능하며 첨자 안에 정수형 인덱스 대신 키값으로 접근

## 집합
- 순서 없기에 첨자로 접근 불가
- 중복 없음

## 부울
- 0, 1은 물론 F/T에 대응
- 빈 문자열/리스트/튜플/딕셔너리/집합도 F로 취급

# 조건문
- if, elif, else
- 각 조건에 걸릴 스코프는 들여쓰기로 구분

# 반복문

## while
- 조건문처럼 들여쓰기로 스코프를 정함
- continue, break

## for
- 문자열, 리스트, 튜플 등 반복가능한 자료형의 원소를 하나씩 접근해 활용
- 리스트 내포로 사용도 가능 (result = [num * 3 for num in a if num % 2 == 0])

# 함수

## 선언
``` python
def 함수명(매개변수들, ..):
    함수 구현
```

혹은 람다를 사용하여
``` python
함수명 = lambda x, y: x + y
```

## 인자 전달
인자를 전달하는 방식은 다양한데
- 그냥 값을 전달할 수도 (add(3, 4))
- 변수를 지정해 전달할 수도 (add(a = 3, b = 4))
- 튜플로 가변인자를 받을 수도 (add(*args), 이 경우 인자들이 args라는 튜플로 전달됨)
- 딕셔너리로 가변인자를 받을 수도 (add(**kwargs), 이 경우 변수를 지정하여 받는 것과 유사한데 파라미터와 인자 쌍들로 구성된 딕셔너리가 전달됨)
- 초기값을 지정할 수도 있다.(add(a, b=4), 이 경우 초기값을 가지는 변수는 그렇지 않은 변수보다 뒤에 와야)

## 스코프
기본적으로 함수 내에서 선언된 변수는 함수 내로 제한되는 스코프를 가지며 함수 밖의 변수에 접근하려면 global 키워드로 변수를 선언하여 전역적으로 접근할 수 있다.

## 반환값
여러 변수를 한 번에 반환할 수 있는데 실은 여러 변수를 튜플로 묶어 그 튜플을 반환하는 것 

# 입출력

## 입력
input()으로 개행문자까지 받으며 input("문구")로 입력 프롬프트를 만들 수 있다. 입력된 값은 문자열 타입.

## 출력
print("문자열들", ...)로 여러 문자열이 콤마로 이어진 경우 띄어쓰기로 문자열들을 이어 생성된 문자열이, 콤마 없이 이어진 경우 바로 +연산으로 이어 생성된 문자열이 만들어진다. 여러 print()함수의 출력이 한 줄로 나오려면 매개변수 end를 사용해 끝 문자 지정(print("문자열", end=' '))

## 파일 입출력

### 스트림
- f = open("경로", '모드')
- 모드엔
    - r
    - w
    - a
- f.close()
- with문으로 자동으로 f.close()시킬 수도
```python
    with open("foo.txt", "w") as f:
        f.write("Life is too short, you need python")
```

### 파일 읽기/쓰기
- f.readline()
- f.readlines()
- f.read()
- f.write()

# 클래스
``` python
class Calculator:
    def __init__(self):
        self.result = 0

    def add(self, num):
        self.result += num
        return self.result

cal1 = Calculator()
```
처럼 사용

- 메서드의 첫 인자로 인스턴스를 받는 특징이 있으며 '인스턴스명.메서드명'으로 접근시 알아서 해당 인스턴스를 넣어줌
- 멤버변수는 따로 선언할 것 없이 메서드에서 언급하면 됨
- 클래스의 정적변수는 클래스 안에 변수를 선언하면 됨
- 생성자는 __init__으로 이름지어야
- 상속은 클래스명 뒤에 괄호로 부모 클래스명 기입
``` python
>>> class MoreFourCal(FourCal):
...     pass
... 
>>>
```
- super() 키워드로 부모 클래스 접근
- 오버로딩 지원 x, *args/**kwargs로 비슷하게 흉내
- 오버라이딩은 같은 이름의 함수 재정의하여 쓸 수 있고 파라미터들이 같은 필요 x

# 모듈
- 모듈은 하나의 .py 파일이며 다른 .py 파일에 불러와 쓸 수 있게 해줌
- import 모듈이름, 
- from 모듈이름 import 모듈의 함수, 변수, 클래스, ...
- as 키워드로 import한 것에 별칭을 붙여줄 수도
- 모듈의 모든 것을 import 할 때 *를 와일드카드로 쓸 수 있음 

# 패키지
모듈의 집합으로 디렉토리 구조를 통해 계층적으로 모듈을 관리할 수 있음
- 패키지의 일부로 인식시킬 디렉토리는 \_\_init\_\_.py 를 작성해야 
- 도트로 import 하는 경우 모듈이나 패키지로 끝내야 (import pkg1.pkg2.mod.func 는 안된다는 소리)
- 모듈과 달리 *를 사용시 다음과 같이 \_\_init\_\_ 안에 명시된 것들만 import 됨
```python
__all__ = ['echo']
```
- 계층 구조이기에 ..나 .을 상대경로로 사용할 수 있음

# 예외
``` python
try:
    code
except someException as e:
    code like print(e)
except anotherException as e:
    print(e)
else:
    code to run when no exception
finally:
    code
```
의 구조이며 raise 키워드로 유발할 수 있다.

## 예외 만들기
``` python
class MyError(Exception):
    def __str__(self):
        return "some_string"
```
print 로 해당 예외를 찍으면 위의 문자열을 출력함.

# 코딩 스타일
- 들여쓴기는 스페이스바 * 4
- 연산자 앞뒤와 콤마 뒤엔 스페이스바
- 클래스는 UpperCamelCase로, 함수/변수/패키지/모듈은 lowercase_with_underscores로, 상수는 소문자가 아닌 대문자로
